#!/usr/bin/env python
PACKAGE = "swanson_algorithms"
from dynamic_reconfigure.parameter_generator_catkin import *
gen = ParameterGenerator()

# Debug Flags
group_cout = gen.add_group("printouts")
group_cout.add("verbose_update",                bool_t,   0, "", False)
group_cout.add("verbose_obstacles",             bool_t,   0, "", False)
group_cout.add("debug_timings",                 bool_t,   0, "", False)
# group_cout.add("debug_gnd_line_removal",        bool_t,   0, "", False)
# group_cout.add("debug_disparity_generation",    bool_t,   0, "NOT USED CURRENTLY", False)
# group_cout.add("debug_published_cloud_sizes",   bool_t,   0, "NOT USED CURRENTLY", False)
# group_cout.add("debug_image_info",              bool_t,   0, "", False)

# Umap contour filtering
group_umap = gen.add_group("umap filtering")
# contourFiltMethEnum = gen.enum([ gen.const("Perimeter", int_t, 1, ""), gen.const("Area", int_t, 2, "")], "")
# group_umap.add("use_custom_umap_filtering",     bool_t,   0, "", True)
# group_umap.add("umap_contour_filter_method",    int_t,    0, "Method used for filtering obstacle contours found in the umap", 1, 1, 2, edit_method=contourFiltMethEnum)
# group_umap.add("umap_contour_min_thresh",       double_t, 0, "Minimum threshold for a contour to count as a potential obstacles",  40.0, 0,   1000.0)
# group_umap.add("umap_simple_thresh_perc",       double_t, 0, "Threshold used for vmap sobel",  0.09, 0,   1.0)
# group_umap.add("pre_blur_thresh",               int_t,    0, "", 25, 0, 256)
# group_umap.add("primary_blur",                  bool_t,   0, "", False)
# group_umap.add("umask_primary_blur_size",       int_t,    0, "", 7, 0, 20)
# group_umap.add("umap_sobel_thresh",             int_t,    0, "", 35, 0, 256)
# group_umap.add("secondary_dilate",              bool_t,   0, "", True)
# group_umap.add("umask_secondary_dilate_sz",     int_t,    0, "", 1, 0, 20)
# group_umap.add("secondary_blur",                bool_t,   0, "", True)
# group_umap.add("umask_secondary_blur_size",     int_t,    0, "", 3, 0, 20)
# group_umap.add("post_blur_thresh",              int_t,    0, "", 30, 0, 256)
# group_umap.add("kernel_x_multiplier",           int_t,    0, "", 10, 0, 20)
# group_umap.add("kernel_y_multiplier",           int_t,    0, "", 2, 0, 20)

group_umap.add("umap_filtering_method",         str_t,   0, "", "sobelized")
group_umap.add("contour_filter_method",         str_t,    0, "Method used for filtering obstacle contours found in the umap", "perimeter")
group_umap.add("contour_min_thresh",            double_t, 0, "Minimum threshold for a contour to count as a potential obstacles",  40.0, 0,   1000.0)
group_umap.add("umap_pre_sobelizing_thresh",         int_t,    0, "", 25, 0, 256)
group_umap.add("umap_sobelized_thresh_prefiltering", int_t,    0, "", 35, 0, 256)
group_umap.add("umap_sobelized_thresh_postfiltering",int_t,    0, "", 30, 0, 256)
group_umap.add("umap_sobelized_dilate_size",         int_t,    0, "", 1, 0, 20)
group_umap.add("umap_sobelized_blur_size",           int_t,    0, "", 3, 0, 20)
group_umap.add("ukernel_x_multiplier",          int_t,    0, "", 10, 0, 20)
group_umap.add("ukernel_y_multiplier",          int_t,    0, "", 2, 0, 20)

# Vmap contour filtering
group_vmap = gen.add_group("vmap filtering")
# group_vmap.add("use_custom_vmap_filtering",     bool_t,   0, "", True)
# group_vmap.add("do_sobel_pre_thresholding",     bool_t,   0, "", False)
# group_vmap.add("sobel_pre_thresh",              int_t,    0, "", 20, 0, 256)
# group_vmap.add("vmask_blur_sobel",              bool_t,   0, "", True)
# group_vmap.add("vmask_blur_size",               int_t,    0, "", 5, 0, 20)
# group_vmap.add("dilate_sobel",                  bool_t,   0, "", False)
# group_vmap.add("vmask_sobel_dilate_sz",         int_t,    0, "", 1, 0, 10)
# group_vmap.add("vmap_sobel_thresh",             int_t,    0, "", 35, 0, 256)
# group_vmap.add("gnd_line_upper_offset",         int_t,    0, "Ground line offset (pixels) above estimated ground line (if found) in the vmap. Note: Used by both methods",  5, 0,   100)
# group_vmap.add("gnd_line_lower_offset",         int_t,    0, "Ground line offset (pixels) below estimated ground line (if found) in the vmap. Note: Used only by ground-line-base method",  25, 0,   100)
# group_vmap.add("gnd_line_max_deg",              double_t, 0, "",  89.0, 0.0,   90.0)
# group_vmap.add("gnd_line_min_deg",              double_t, 0, "",  26.0, 0.0,   90.0)
# group_vmap.add("vmask_subtract_sobel",          bool_t,   0, "", True)
# group_vmap.add("do_secondary_sobel_thresholding",bool_t,   0, "", True)
# group_vmap.add("vmap_sobel_sec_thresh",         int_t,    0, "", 40, 0, 256)
# group_vmap.add("vmask_sec_blur_sobel",          bool_t,   0, "", True)
# group_vmap.add("vmask_secondary_blur_size",     int_t,    0, "", 7, 0, 20)
# group_vmap.add("dilate_secondary_sobel",        bool_t,   0, "", False)
# group_vmap.add("vmask_sobel_dilate_sec_sz",     int_t,    0, "", 1, 0, 10)
# group_vmap.add("vmap_thresh",                   int_t,    0, "", 5, 0, 256)

group_vmap.add("vmap_filtering_method",                         str_t, 0, "", "sobelized")
group_vmap.add("vmap_sobel_preprocessing_thresh",               int_t, 0, "", 35, 0, 256)
group_vmap.add("vmap_sobel_preprocessing_blur_size",            int_t, 0, "", 5, 0, 20)
group_vmap.add("vmap_sobel_postprocessing_thresh_prefiltering", int_t, 0, "", 40, 0, 256)
group_vmap.add("vmap_sobel_postprocessing_thresh_postfiltering",int_t, 0, "", 5, 0, 256)
group_vmap.add("vmap_sobel_postprocessing_blur_size",           int_t, 0, "", 7, 0, 20)
group_vmap.add("vkernel_x_multiplier",                          int_t, 0, "", 1, 0, 20)
group_vmap.add("vkernel_y_multiplier",                          int_t, 0, "", 1, 0, 20)
group_vmap.add("gnd_line_intercept_offset",     int_t,    0, "Offset (pixels) of estimated ground line y-intercept (if found) in the vmap. Note: (+) to lower and (-) to raise",  5, 0,   100)
group_vmap.add("gnd_line_search_hough_thresh",  int_t,    0, "",  100, 0,   1000)
group_vmap.add("gnd_line_search_max_deg",       double_t, 0, "",  89.0, 0.0,   90.0)
group_vmap.add("gnd_line_search_min_deg",       double_t, 0, "",  26.0, 0.0,   90.0)
group_vmap.add("gnd_line_search_deadzone",      double_t, 0, "",  2.0, 0.0,   90.0)

group_cfg = gen.add_group("config")
group_cfg.add("depth_absolute_min",             double_t, 0, "", 0.01, 0.0, 100.0)
group_cfg.add("depth_absolute_max",             double_t, 0, "", 10.0, 0.0, 100.0)
group_cfg.add("do_angle_correction",            bool_t,   0, "", True)
group_cfg.add("angle_correction_method",        str_t, 0, "", "roll")
group_cfg.add("correction_angle_offset_deg",    double_t, 0, "", 0.0, -180.0, 180.0)
group_cfg.add("debug_angle_inputs",             bool_t,   0, "", False)
group_cfg.add("flip_correction_angle_sign",     bool_t,   0, "", False)
group_cfg.add("do_obstacle_data_extraction",    bool_t,   0, "", True)
group_cfg.add("do_post_depth_denoising",        bool_t,   0, "", True)
group_cfg.add("depth_denoising_kernel_size",    int_t,    0, "", 2, 0, 20)
group_cfg.add("cam_min_depth_x",                double_t, 0, "TODO: Intergrate this", 0.0, -20.0, 20.0)
group_cfg.add("cam_max_depth_x",                double_t, 0, "TODO: Intergrate this", 0.0, -20.0, 20.0)
group_cfg.add("cam_min_depth_y",                double_t, 0, "TODO: Intergrate this", -0.5, -20.0, 20.0)
group_cfg.add("cam_max_depth_y",                double_t, 0, "TODO: Intergrate this", 0.0, -20.0, 20.0)

# Pointcloud filtering parameters
group_pcl_filter = gen.add_group("cloud_filtering")
group_pcl_filter.add("do_cloud_limit_filtering",bool_t,   0, "Enables pointcloud filtering using defined limits",  True)
group_pcl_filter.add("min_cloud_range",         double_t, 0, "Min Distance (m) used for filtering extracted pointcloud",  0.1, 0,   25.0)
group_pcl_filter.add("max_cloud_range",         double_t, 0, "Min Height (m) used for filtering extracted pointcloud",  20.0, 0,   25.0)
group_pcl_filter.add("min_cloud_height",        double_t, 0, "Max Distance (m) used for filtering extracted pointcloud",  1.0, -5.0,   5.0)
group_pcl_filter.add("max_cloud_height",        double_t, 0, "Max Height (m) used for filtering extracted pointcloud",  0.5, -5.0,   5.0)
group_pcl_filter.add("do_cloud_downsampling",   bool_t,   0, "Enables pointcloud downsampling into voxels",  False)
group_pcl_filter.add("voxel_res_x",             double_t, 0, "Voxel resolution (m) in the X-axis",  0.02, 0,  2.0)
group_pcl_filter.add("voxel_res_y",             double_t, 0, "Voxel resolution (m) in the Y-axis",  0.02, 0,  2.0)
group_pcl_filter.add("voxel_res_z",             double_t, 0, "Voxel resolution (m) in the Z-axis",  0.02, 0,  2.0)
group_pcl_filter.add("do_cloud_outlier_removal",bool_t,   0, "Enables pointcloud filtering using radial outlier removal",  True)
group_pcl_filter.add("cloud_outlier_search_radius",double_t, 0, "Radial distance (m) around a point in the pointcloud used for finding sor_min_neighbors. Used in pointcloud filtering.",  0.075, 0,   5.0)
group_pcl_filter.add("cloud_outlier_min_neighbors",int_t,    0, "Minimum number of neighbors around a point in the pointcloud to be an acceptable point. Used in pointcloud filtering.",  10, 0,   100)

group_pub = gen.add_group("publishing")
group_pub.add("publish_obstacle_data",          bool_t,     0, "", True)
group_pub.add("publish_obstacle_image",         bool_t,     0, "", True)
group_pub.add("publish_raw_cloud",              bool_t,     0, "", False)
group_pub.add("publish_filter_cloud",           bool_t,     0, "", True)
group_pub.add("publish_unfilter_cloud",         bool_t,     0, "", False)

group_pub.add("publish_corrected_depth",        bool_t,     0, "", False)
group_pub.add("publish_generated_disparity",    bool_t,     0, "", False)
group_pub.add("publish_umap_raw",               bool_t,     0, "", False)
group_pub.add("publish_vmap_raw",               bool_t,     0, "", False)
group_pub.add("publish_umap_processed",         bool_t,     0, "", False)
group_pub.add("publish_vmap_processed",         bool_t,     0, "", False)

midLvlDbgGroup = gen.add_group("mid_lvl_debug")
midLvlDbgGroup.add("publish_mid_level_debug_images",                 bool_t,   0, "", False)
midLvlDbgGroup.add("visualize_gnd_line_keep_mask",                   bool_t,   0, "", False)
midLvlDbgGroup.add("visualize_obj_candidate_keep_mask",              bool_t,   0, "", False)
midLvlDbgGroup.add("visualize_umap_keep_mask",                       bool_t,   0, "", False)
midLvlDbgGroup.add("visualize_vmap_keep_mask",                       bool_t,   0, "", False)

lowLvlDbgGroup = gen.add_group("low_lvl_debug")
lowLvlDbgGroup.add("overlay_filtered_contours",                      bool_t,     0, "", True)
lowLvlDbgGroup.add("overlay_gnd_lines",                              bool_t,     0, "", True)
lowLvlDbgGroup.add("overlay_object_search_windows",                  bool_t,     0, "", True)
lowLvlDbgGroup.add("publish_low_level_debug_images",                 bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_debug_tile_names",                     bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_umap_raw",                             bool_t,   0, "", True)
lowLvlDbgGroup.add("visualize_vmap_raw",                             bool_t,   0, "", True)
lowLvlDbgGroup.add("visualize_umap_processed",                       bool_t,   0, "", True)
lowLvlDbgGroup.add("visualize_vmap_processed",                       bool_t,   0, "", True)
lowLvlDbgGroup.add("visualize_umap_sobel_raw",                       bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_umap_sobel_preprocessed",              bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_umap_sobel_dilated",                   bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_umap_sobel_blurred",                   bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_vmap_sobelized_preprocessed",          bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_vmap_sobelized_postprocessed_threshed",bool_t,   0, "", False)
lowLvlDbgGroup.add("visualize_vmap_sobelized_postprocessed_blurred", bool_t,   0, "", False)

exit(gen.generate(PACKAGE, "swanson_algorithms", "Vboats"))
