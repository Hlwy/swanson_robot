Param: Bayes/FullPredictionUpdate = "false"                [Regenerate all the prediction matrix on each iteration (otherwise only removed/added ids are updated).]
Param: Bayes/PredictionLC = "0.1 0.36 0.30 0.16 0.062 0.0151 0.00255 0.000324 2.5e-05 1.3e-06 4.8e-08 1.2e-09 1.9e-11 2.2e-13 1.7e-15 8.5e-18 2.9e-20 6.9e-23" [Prediction of loop closures (Gaussian-like, here with sigma=1.6) - Format: {VirtualPlaceProb, LoopClosureProb, NeighborLvl1, NeighborLvl2, ...}.]
Param: Bayes/VirtualPlacePriorThr = "0.9"                  [Virtual place prior]
Param: GFTT/BlockSize = "3"                                []
Param: GFTT/K = "0.04"                                     []
Param: GFTT/MinDistance = "3"                              []
Param: GFTT/QualityLevel = "0.001"                         []
Param: GFTT/UseHarrisDetector = "false"                    []
Param: GTSAM/Optimizer = "1"                               [0=Levenberg 1=GaussNewton 2=Dogleg]
Param: Grid/3D = "true"                                    [A 3D occupancy grid is required if you want an OctoMap (3D ray tracing). Set to false if you want only a 2D map, the cloud will be projected on xy plane. A 2D map can be still generated if checked, but it requires more memory and time to generate it. Ignored if laser scan is 2D and "Grid/FromDepth" is false.]
Param: Grid/CellSize = "0.05"                              [Resolution of the occupancy grid.]
Param: Grid/ClusterRadius = "0.1"                          [[Grid/NormalsSegmentation=true] Cluster maximum radius.]
Param: Grid/DepthDecimation = "4"                          [[Grid/DepthDecimation=true] Decimation of the depth image before creating cloud. Negative decimation is done from RGB size instead of depth size (if depth is smaller than RGB, it may be interpolated depending of the decimation value).]
Param: Grid/DepthRoiRatios = "0.0 0.0 0.0 0.0"             [[Grid/FromDepth=true] Region of interest ratios [left, right, top, bottom].]
Param: Grid/FlatObstacleDetected = "true"                  [[Grid/NormalsSegmentation=true] Flat obstacles detected.]
Param: Grid/FootprintHeight = "0.0"                        [Footprint height used to filter points over the footprint of the robot. Footprint length and width should be set.]
Param: Grid/FootprintLength = "0.0"                        [Footprint length used to filter points over the footprint of the robot.]
Param: Grid/FootprintWidth = "0.0"                         [Footprint width used to filter points over the footprint of the robot. Footprint length should be set.]
Param: Grid/FromDepth = "true"                             [Create occupancy grid from depth image(s), otherwise it is created from laser scan.]
Param: Grid/GroundIsObstacle = "false"                     [[Grid/3D=true] Ground segmentation (Grid/NormalsSegmentation) is ignored, all points are obstacles. Use this only if you want an OctoMap with ground identified as an obstacle (e.g., with an UAV).]
Param: Grid/MapFrameProjection = "false"                   [Projection in map frame. On a 3D terrain and a fixed local camera transform (the cloud is created relative to ground), you may want to disable this to do the projection in robot frame instead.]
Param: Grid/MaxGroundAngle = "45"                          [[Grid/NormalsSegmentation=true] Maximum angle (degrees) between point's normal to ground's normal to label it as ground. Points with higher angle difference are considered as obstacles.]
Param: Grid/MaxGroundHeight = "0.0"                        [Maximum ground height (0=disabled). Should be set if "Grid/NormalsSegmentation" is false.]
Param: Grid/MaxObstacleHeight = "0.0"                      [Maximum obstacles height (0=disabled).]
Param: Grid/MinClusterSize = "10"                          [[Grid/NormalsSegmentation=true] Minimum cluster size to project the points.]
Param: Grid/MinGroundHeight = "0.0"                        [Minimum ground height (0=disabled).]
Param: Grid/NoiseFilteringMinNeighbors = "5"               [Noise filtering minimum neighbors.]
Param: Grid/NoiseFilteringRadius = "0.0"                   [Noise filtering radius (0=disabled). Done after segmentation.]
Param: Grid/NormalK = "20"                                 [[Grid/NormalsSegmentation=true] K neighbors to compute normals.]
Param: Grid/NormalsSegmentation = "true"                   [Segment ground from obstacles using point normals, otherwise a fast passthrough is used.]
Param: Grid/PreVoxelFiltering = "true"                     [Input cloud is downsampled by voxel filter (voxel size is "Grid/CellSize") before doing segmentation of obstacles and ground.]
Param: Grid/RangeMax = "5.0"                               [Maximum range from sensor. 0=inf.]
Param: Grid/RangeMin = "0.0"                               [Minimum range from sensor.]
Param: Grid/RayTracing = "false"                           [Ray tracing is done for each occupied cell, filling unknown space between the sensor and occupied cells. If Grid/3D=true, RTAB-Map should be built with OctoMap support, otherwise 3D ray tracing is ignored.]
Param: Grid/Scan2dUnknownSpaceFilled = "false"             [Unknown space filled. Only used with 2D laser scans. Use Grid/RangeMax to set maximum range if laser scan max range is to set.]
Param: Grid/ScanDecimation = "1"                           [[Grid/FromDepth=false] Decimation of the laser scan before creating cloud.]
Param: GridGlobal/Eroded = "false"                         [Erode obstacle cells.]
Param: GridGlobal/FootprintRadius = "0.0"                  [Footprint radius (m) used to clear all obstacles under the graph.]
Param: GridGlobal/FullUpdate = "true"                      [When the graph is changed, the whole map will be reconstructed instead of moving individually each cells of the map. Also, data added to cache won't be released after updating the map. This process is longer but more robust to drift that would erase some parts of the map when it should not.]
Param: GridGlobal/MaxNodes = "0"                           [Maximum nodes assembled in the map starting from the last node (0=unlimited).]
Param: GridGlobal/MinSize = "0.0"                          [Minimum map size (m).]
Param: GridGlobal/OccupancyThr = "0.5"                     [Occupancy threshold (value between 0 and 1).]
Param: GridGlobal/ProbClampingMax = "0.971"                [Probability clamping maximum (value between 0 and 1).]
Param: GridGlobal/ProbClampingMin = "0.1192"               [Probability clamping minimum (value between 0 and 1).]
Param: GridGlobal/ProbHit = "0.7"                          [Probability of a hit (value between 0.5 and 1).]
Param: GridGlobal/ProbMiss = "0.4"                         [Probability of a miss (value between 0 and 0.5).]
Param: GridGlobal/UpdateError = "0.01"                     [Graph changed detection error (m). Update map only if poses in new optimized graph have moved more than this value.]
Param: Kp/BadSignRatio = "0.5"                             [Bad signature ratio (less than Ratio x AverageWordsPerImage = bad).]
Param: Kp/DetectorStrategy = "6"                           [0=SURF 1=SIFT 2=ORB 3=FAST/FREAK 4=FAST/BRIEF 5=GFTT/FREAK 6=GFTT/BRIEF 7=BRISK 8=GFTT/ORB 9=KAZE 10=ORB-OCTREE.]
Param: Kp/DictionaryPath = ""                              [Path of the pre-computed dictionary]
Param: Kp/FlannRebalancingFactor = "2.0"                   [Factor used when rebuilding the incremental FLANN index (see "Kp/IncrementalFlann"). Set <=1 to disable.]
Param: Kp/GridCols = "1"                                   [Number of columns of the grid used to extract uniformly "Kp/MaxFeatures / grid cells" features from each cell.]
Param: Kp/GridRows = "1"                                   [Number of rows of the grid used to extract uniformly "Kp/MaxFeatures / grid cells" features from each cell.]
Param: Kp/IncrementalDictionary = "true"                   []
Param: Kp/IncrementalFlann = "true"                        [When using FLANN based strategy, add/remove points to its index without always rebuilding the index (the index is built only when the dictionary increases of the factor "Kp/FlannRebalancingFactor" in size).]
Param: Kp/MaxDepth = "0"                                   [Filter extracted keypoints by depth (0=inf).]
Param: Kp/MaxFeatures = "500"                              [Maximum features extracted from the images (0 means not bounded, <0 means no extraction).]
Param: Kp/MinDepth = "0"                                   [Filter extracted keypoints by depth.]
Param: Kp/NNStrategy = "1"                                 [kNNFlannNaive=0, kNNFlannKdTree=1, kNNFlannLSH=2, kNNBruteForce=3, kNNBruteForceGPU=4]
Param: Kp/NewWordsComparedTogether = "true"                [When adding new words to dictionary, they are compared also with each other (to detect same words in the same signature).]
Param: Kp/NndrRatio = "0.8"                                [NNDR ratio (A matching pair is detected, if its distance is closer than X times the distance of the second nearest neighbor.)]
Param: Kp/Parallelized = "true"                            [If the dictionary update and signature creation were parallelized.]
Param: Kp/RoiRatios = "0.0 0.0 0.0 0.0"                    [Region of interest ratios [left, right, top, bottom].]
Param: Kp/SubPixEps = "0.02"                               [See cv::cornerSubPix().]
Param: Kp/SubPixIterations = "0"                           [See cv::cornerSubPix(). 0 disables sub pixel refining.]
Param: Kp/SubPixWinSize = "3"                              [See cv::cornerSubPix().]
Param: Kp/TfIdfLikelihoodUsed = "true"                     [Use of the td-idf strategy to compute the likelihood.]
Param: Marker/CornerRefinementMethod = "0"                 [Corner refinement method (0: None, 1: Subpixel, 2:contour, 3: AprilTag2). For OpenCV <3.3.0, this is "doCornerRefinement" parameter: set 0 for false and 1 for true.]
Param: Marker/Length = "0"                                 [The length (m) of the markers' side. 0 means automatic marker length estimation using the depth image (the camera should look at the marker perpendicularly for initialization).]
Param: Marker/MaxDepthError = "0.01"                       [Maximum depth error between all corners of a marker when estimating the marker length (when Marker/Length is 0). The smaller it is, the more perpendicular the camera should be toward the marker to initialize the length.]
Param: Marker/VarianceAngular = "0.01"                     [Angular variance to set on marker detections. Set to >=9999 to use only position (xyz) constraint in graph optimization.]
Param: Marker/VarianceLinear = "0.001"                     [Linear variance to set on marker detections.]
Param: Mem/BadSignaturesIgnored = "false"                  [Bad signatures are ignored.]
Param: Mem/BinDataKept = "true"                            [Keep binary data in db.]
Param: Mem/CompressionParallelized = "true"                [Compression of sensor data is multi-threaded.]
Param: Mem/CovOffDiagIgnored = "true"                      [Ignore off diagonal values of the covariance matrix.]
Param: Mem/DepthAsMask = "true"                            [Use depth image as mask when extracting features for vocabulary.]
Param: Mem/GenerateIds = "true"                            [True=Generate location IDs, False=use input image IDs.]
Param: Mem/ImageCompressionFormat = ".jpg"                 [RGB image compression format. It should be ".jpg" or ".png".]
Param: Mem/ImageKept = "false"                             [Keep raw images in RAM.]
Param: Mem/ImagePostDecimation = "1"                       [Image decimation (>=1) of saved data in created signatures (after features extraction). Decimation is done from the original image.]
Param: Mem/ImagePreDecimation = "1"                        [Image decimation (>=1) before features extraction.]
Param: Mem/IncrementalMemory = "true"                      [SLAM mode, otherwise it is Localization mode.]
Param: Mem/InitWMWithAllNodes = "false"                    [Initialize the Working Memory with all nodes in Long-Term Memory. When false, it is initialized with nodes of the previous session.]
Param: Mem/IntermediateNodeDataKept = "false"              [Keep intermediate node data in db.]
Param: Mem/MapLabelsAdded = "true"                         [Create map labels. The first node of a map will be labelled as "map#" where # is the map ID.]
Param: Mem/NotLinkedNodesKept = "true"                     [Keep not linked nodes in db (rehearsed nodes and deleted nodes).]
Param: Mem/RawDescriptorsKept = "true"                     [Raw descriptors kept in memory.]
Param: Mem/RecentWmRatio = "0.2"                           [Ratio of locations after the last loop closure in WM that cannot be transferred.]
Param: Mem/ReduceGraph = "false"                           [Reduce graph. Merge nodes when loop closures are added (ignoring those with user data set).]
Param: Mem/RehearsalIdUpdatedToNewOne = "false"            [On merge, update to new id. When false, no copy.]
Param: Mem/RehearsalSimilarity = "0.6"                     [Rehearsal similarity.]
Param: Mem/RehearsalWeightIgnoredWhileMoving = "false"     [When the robot is moving, weights are not updated on rehearsal.]
Param: Mem/STMSize = "10"                                  [Short-term memory size.]
Param: Mem/SaveDepth16Format = "false"                     [Save depth image into 16 bits format to reduce memory used. Warning: values over ~65 meters are ignored (maximum 65535 millimeters).]
Param: Mem/TransferSortingByWeightId = "false"             [On transfer, signatures are sorted by weight->ID only (i.e. the oldest of the lowest weighted signatures are transferred first). If false, the signatures are sorted by weight->Age->ID (i.e. the oldest inserted in WM of the lowest weighted signatures are transferred first). Note that retrieval updates the age, not the ID.]
Param: Mem/UseOdomFeatures = "true"                        [Use odometry features instead of regenerating them.]
Param: Mem/UseOdomGravity = "false"                        [Use odometry instead of IMU orientation to add gravity links to new nodes created. We assume that odometry is already aligned with gravity (e.g., we are using a VIO approach). Gravity constraints are used by graph optimization only if "Optimizer/GravitySigma" is not zero.]
Param: Optimizer/Epsilon = "0.00001"                       [Stop optimizing when the error improvement is less than this value.]
Param: Optimizer/GravitySigma = "0.0"                      [Gravity sigma value (>=0, typically between 0.1 and 0.3). Optimization is done while preserving gravity orientation of the poses. This should be used only with visual/lidar inertial odometry approaches, for which we assume that all odometry poses are aligned with gravity. Set to 0 to disable gravity constraints. Currently supported only with g2o and GTSAM optimization strategies (see Optimizer/Strategy).]
Param: Optimizer/Iterations = "20"                         [Optimization iterations.]
Param: Optimizer/LandmarksIgnored = "false"                [Ignore landmark constraints while optimizing. Currently only g2o and gtsam optimization supports this.]
Param: Optimizer/PriorsIgnored = "true"                    [Ignore prior constraints (global pose or GPS) while optimizing. Currently only g2o and gtsam optimization supports this.]
Param: Optimizer/Robust = "false"                          [Robust graph optimization using Vertigo (only work for g2o and GTSAM optimization strategies). Not compatible with "RGBD/OptimizeMaxError" if enabled.]
Param: Optimizer/Strategy = "2"                            [Graph optimization strategy: 0=TORO, 1=g2o, 2=GTSAM and 3=Ceres.]
Param: Optimizer/VarianceIgnored = "false"                 [Ignore constraints' variance. If checked, identity information matrix is used for each constraint. Otherwise, an information matrix is generated from the variance saved in the links.]
Param: RGBD/AngularSpeedUpdate = "0.0"                     [Maximum angular speed (rad/s) to update the map (0 means not limit).]
Param: RGBD/AngularUpdate = "0.1"                          [Minimum angular displacement (rad) to update the map. Rehearsal is done prior to this, so weights are still updated.]
Param: RGBD/CreateOccupancyGrid = "true"                   [Create local occupancy grid maps. See "Grid" group for parameters.]
Param: RGBD/Enabled = "true"                               []
Param: RGBD/LinearSpeedUpdate = "0.0"                      [Maximum linear speed (m/s) to update the map (0 means not limit).]
Param: RGBD/LinearUpdate = "0.1"                           [Minimum linear displacement (m) to update the map. Rehearsal is done prior to this, so weights are still updated.]
Param: RGBD/LocalBundleOnLoopClosure = "false"             [Do local bundle adjustment with neighborhood of the loop closure.]
Param: RGBD/LocalImmunizationRatio = "0.25"                [Ratio of working memory for which local nodes are immunized from transfer.]
Param: RGBD/LocalRadius = "10"                             [Local radius (m) for nodes selection in the local map. This parameter is used in some approaches about the local map management.]
Param: RGBD/LoopClosureReextractFeatures = "false"         [Extract features even if there are some already in the nodes.]
Param: RGBD/LoopCovLimited = "false"                       [Limit covariance of non-neighbor links to minimum covariance of neighbor links. In other words, if covariance of a loop closure link is smaller than the minimum covariance of odometry links, its covariance is set to minimum covariance of odometry links.]
Param: RGBD/MarkerDetection = "false"                      [Detect static markers to be added as landmarks for graph optimization. If input data have already landmarks, this will be ignored. See "Marker" group for parameters.]
Param: RGBD/MaxLocalRetrieved = "2"                        [Maximum local locations retrieved (0=disabled) near the current pose in the local map or on the current planned path (those on the planned path have priority).]
Param: RGBD/MaxLoopClosureDistance = "0.0"                 [Reject loop closures/localizations if the distance from the map is over this distance (0=disabled).]
Param: RGBD/MaxOdomCacheSize = "0"                         [Maximum odometry cache size. Used only in localization mode (when Mem/IncrementalMemory=false) and when RGBD/OptimizeMaxError!=0. This is used to verify localization transforms to make sure we don't teleport to a location very similar to one we previously localized on. When the cache is full, the whole cache is cleared and the next localization is automatically accepted without verification. Set 0 to disable caching.]
Param: RGBD/NeighborLinkRefining = "false"                 [When a new node is added to the graph, the transformation of its neighbor link to the previous node is refined using registration approach selected (Reg/Strategy).]
Param: RGBD/NewMapOdomChangeDistance = "0"                 [A new map is created if a change of odometry translation greater than X m is detected (0 m = disabled).]
Param: RGBD/OptimizeFromGraphEnd = "false"                 [Optimize graph from the newest node. If false, the graph is optimized from the oldest node of the current graph (this adds an overhead computation to detect to oldest node of the current graph, but it can be useful to preserve the map referential from the oldest node). Warning when set to false: when some nodes are transferred, the first referential of the local map may change, resulting in momentary changes in robot/map position (which are annoying in teleoperation).]
Param: RGBD/OptimizeMaxError = "3.0"                       [Reject loop closures if optimization error ratio is greater than this value (0=disabled). Ratio is computed as absolute error over standard deviation of each link. This will help to detect when a wrong loop closure is added to the graph. Not compatible with "Optimizer/Robust" if enabled.]
Param: RGBD/SavedLocalizationIgnored = "false"             [Ignore last saved localization pose from previous session. If true, RTAB-Map won't assume it is restarting from the same place than where it shut down previously.]
Param: RGBD/ScanMatchingIdsSavedInLinks = "true"           [Save scan matching IDs in link's user data.]
Param: Reg/Force3DoF = "false"                             [Force 3 degrees-of-freedom transform (3Dof: x,y and yaw). Parameters z, roll and pitch will be set to 0.]
Param: Reg/RepeatOnce = "true"                             [Do a second registration with the output of the first registration as guess. Only done if no guess was provided for the first registration (like on loop closure). It can be useful if the registration approach used can use a guess to get better matches.]
Param: Reg/Strategy = "0"                                  [0=Vis, 1=Icp, 2=VisIcp]
Param: Rtabmap/ComputeRMSE = "true"                        [Compute root mean square error (RMSE) and publish it in statistics, if ground truth is provided.]
Param: Rtabmap/CreateIntermediateNodes = "false"           [Create intermediate nodes between loop closure detection. Only used when Rtabmap/DetectionRate>0.]
Param: Rtabmap/DetectionRate = "1"                         [Detection rate (Hz). RTAB-Map will filter input images to satisfy this rate.]
Param: Rtabmap/ImageBufferSize = "1"                       [Data buffer size (0 min inf).]
Param: Rtabmap/ImagesAlreadyRectified = "true"             [Images are already rectified. By default RTAB-Map assumes that received images are rectified. If they are not, they can be rectified by RTAB-Map if this parameter is false.]
Param: Rtabmap/LoopGPS = "true"                            [Use GPS to filter likelihood (if GPS is recorded). Only locations inside the local radius "RGBD/LocalRadius" of the current GPS location are considered for loop closure detection.]
Param: Rtabmap/LoopRatio = "0"                             [The loop closure hypothesis must be over LoopRatio x lastHypothesisValue.]
Param: Rtabmap/LoopThr = "0.11"                            [Loop closing threshold.]
Param: Rtabmap/MaxRetrieved = "2"                          [Maximum locations retrieved at the same time from LTM.]
Param: Rtabmap/MemoryThr = "0"                             [Maximum nodes in the Working Memory (0 means infinity). Similar to "Rtabmap/TimeThr", when the number of nodes in Working Memory (WM) exceeds this treshold, some nodes are transferred to Long-Term Memory to keep WM size fixed.]
Param: Rtabmap/PublishLastSignature = "true"               [Publishing last signature.]
Param: Rtabmap/PublishLikelihood = "true"                  [Publishing likelihood.]
Param: Rtabmap/PublishPdf = "true"                         [Publishing pdf.]
Param: Rtabmap/PublishRAMUsage = "false"                   [Publishing RAM usage in statistics (may add a small overhead to get info from the system).]
Param: Rtabmap/PublishStats = "true"                       [Publishing statistics.]
Param: Rtabmap/RectifyOnlyFeatures = "false"               [If "Rtabmap/ImagesAlreadyRectified" is false and this parameter is true, the whole RGB image will not be rectified, only the features. Warning: As projection of RGB-D image to point cloud is assuming that images are rectified, the generated point cloud map will have wrong colors if this parameter is true.]
Param: Rtabmap/SaveWMState = "false"                       [Save working memory state after each update in statistics.]
Param: Rtabmap/StartNewMapOnGoodSignature = "false"        [Start a new map only if the first signature is not bad (i.e., has enough features, see Kp/BadSignRatio).]
Param: Rtabmap/StartNewMapOnLoopClosure = "false"          [Start a new map only if there is a global loop closure with a previous map.]
Param: Rtabmap/StatisticLogged = "false"                   [Logging enabled.]
Param: Rtabmap/StatisticLoggedHeaders = "true"             [Add column header description to log files.]
Param: Rtabmap/StatisticLogsBufferedInRAM = "true"         [Statistic logs buffered in RAM instead of written to hard drive after each iteration.]
Param: Rtabmap/TimeThr = "0"                               [Maximum time allowed for map update (ms) (0 means infinity). When map update time exceeds this fixed time threshold, some nodes in Working Memory (WM) are transferred to Long-Term Memory to limit the size of the WM and decrease the update time.]
Param: Rtabmap/WorkingDirectory = "/home/hunter/.ros"      [Working directory.]
Param: VhEp/Enabled = "false"                              [Verify visual loop closure hypothesis by computing a fundamental matrix. This is done prior to transformation computation when RGBD/Enabled is enabled.]
Param: VhEp/MatchCountMin = "8"                            [Minimum of matching visual words pairs to accept the loop hypothesis.]
Param: VhEp/RansacParam1 = "3"                             [Fundamental matrix (see cvFindFundamentalMat()): Max distance (in pixels) from the epipolar line for a point to be inlier.]
Param: VhEp/RansacParam2 = "0.99"                          [Fundamental matrix (see cvFindFundamentalMat()): Performance of RANSAC.]
Param: Vis/BundleAdjustment = "1"                          [Optimization with bundle adjustment: 0=disabled, 1=g2o, 2=cvsba, 3=Ceres.]
Param: Vis/CorFlowEps = "0.01"                             [[Vis/CorType=1] See cv::calcOpticalFlowPyrLK(). Used for optical flow approach.]
Param: Vis/CorFlowIterations = "30"                        [[Vis/CorType=1] See cv::calcOpticalFlowPyrLK(). Used for optical flow approach.]
Param: Vis/CorFlowMaxLevel = "3"                           [[Vis/CorType=1] See cv::calcOpticalFlowPyrLK(). Used for optical flow approach.]
Param: Vis/CorFlowWinSize = "16"                           [[Vis/CorType=1] See cv::calcOpticalFlowPyrLK(). Used for optical flow approach.]
Param: Vis/CorGuessMatchToProjection = "false"             [[Vis/CorType=0] Match frame's corners to source's projected points (when guess transform is provided) instead of projected points to frame's corners.]
Param: Vis/CorGuessWinSize = "20"                          [[Vis/CorType=0] Matching window size (pixels) around projected points when a guess transform is provided to find correspondences. 0 means disabled.]
Param: Vis/CorNNDR = "0.6"                                 [[Vis/CorType=0] NNDR: nearest neighbor distance ratio. Used for features matching approach.]
Param: Vis/CorNNType = "1"                                 [[Vis/CorType=0] kNNFlannNaive=0, kNNFlannKdTree=1, kNNFlannLSH=2, kNNBruteForce=3, kNNBruteForceGPU=4. Used for features matching approach.]
Param: Vis/CorType = "0"                                   [Correspondences computation approach: 0=Features Matching, 1=Optical Flow]
Param: Vis/DepthAsMask = "true"                            [Use depth image as mask when extracting features.]
Param: Vis/EpipolarGeometryVar = "0.02"                    [[Vis/EstimationType = 2] Epipolar geometry maximum variance to accept the transformation.]
Param: Vis/EstimationType = "1"                            [Motion estimation approach: 0:3D->3D, 1:3D->2D (PnP), 2:2D->2D (Epipolar Geometry)]
Param: Vis/FeatureType = "6"                               [0=SURF 1=SIFT 2=ORB 3=FAST/FREAK 4=FAST/BRIEF 5=GFTT/FREAK 6=GFTT/BRIEF 7=BRISK 8=GFTT/ORB 9=KAZE 10=ORB-OCTREE.]
Param: Vis/ForwardEstOnly = "true"                         [Forward estimation only (A->B). If false, a transformation is also computed in backward direction (B->A), then the two resulting transforms are merged (middle interpolation between the transforms).]
Param: Vis/GridCols = "1"                                  [Number of columns of the grid used to extract uniformly "Vis/MaxFeatures / grid cells" features from each cell.]
Param: Vis/GridRows = "1"                                  [Number of rows of the grid used to extract uniformly "Vis/MaxFeatures / grid cells" features from each cell.]
Param: Vis/InlierDistance = "0.1"                          [[Vis/EstimationType = 0] Maximum distance for feature correspondences. Used by 3D->3D estimation approach.]
Param: Vis/Iterations = "300"                              [Maximum iterations to compute the transform.]
Param: Vis/MaxDepth = "0"                                  [Max depth of the features (0 means no limit).]
Param: Vis/MaxFeatures = "1000"                            [0 no limits.]
Param: Vis/MeanInliersDistance = "0.0"                     [Maximum distance (m) of the mean distance of inliers from the camera to accept the transformation. 0 means disabled.]
Param: Vis/MinDepth = "0"                                  [Min depth of the features (0 means no limit).]
Param: Vis/MinInliers = "20"                               [Minimum feature correspondences to compute/accept the transformation.]
Param: Vis/MinInliersDistribution = "0.0"                  [Minimum distribution value of the inliers in the image to accept the transformation. The distribution is the second eigen value of the PCA (Principal Component Analysis) on the keypoints of the normalized image [-0.5, 0.5]. The value would be between 0 and 0.5. 0 means disabled.]
Param: Vis/PnPFlags = "0"                                  [[Vis/EstimationType = 1] PnP flags: 0=Iterative, 1=EPNP, 2=P3P]
Param: Vis/PnPRefineIterations = "0"                       [[Vis/EstimationType = 1] Refine iterations. Set to 0 if "Vis/BundleAdjustment" is also used.]
Param: Vis/PnPReprojError = "2"                            [[Vis/EstimationType = 1] PnP reprojection error.]
Param: Vis/RefineIterations = "5"                          [[Vis/EstimationType = 0] Number of iterations used to refine the transformation found by RANSAC. 0 means that the transformation is not refined.]
Param: Vis/SubPixEps = "0.02"                              [See cv::cornerSubPix().]
Param: Vis/SubPixIterations = "0"                          [See cv::cornerSubPix(). 0 disables sub pixel refining.]
Param: Vis/SubPixWinSize = "3"                             [See cv::cornerSubPix().]
Param: g2o/Baseline = "0.075"                              [When doing bundle adjustment with RGB-D data, we can set a fake baseline (m) to do stereo bundle adjustment (if 0, mono bundle adjustment is done). For stereo data, the baseline in the calibration is used directly.]
Param: g2o/Optimizer = "0"                                 [0=Levenberg 1=GaussNewton]
Param: g2o/PixelVariance = "1.0"                           [Pixel variance used for bundle adjustment.]
Param: g2o/RobustKernelDelta = "8"                         [Robust kernel delta used for bundle adjustment (0 means don't use robust kernel). Observations with chi2 over this threshold will be ignored in the second optimization pass.]
Param: g2o/Solver = "0"                                    [0=csparse 1=pcg 2=cholmod 3=Eigen]
